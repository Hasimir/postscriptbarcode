%!PS

/barcode <
5562756e7475efbc88e4b98ce78fade59bbeefbc89e698afe4b880e4b8aae4bb
a5e6a18ce99da2e5ba94e794a8e4b8bae4b8bbe79a844c696e7578e6938de4bd
9ce7b3bbe7bb9fefbc8ce585b6e5908de7a7b0e69da5e887aae99d9ee6b4b2e5
8d97e983a8e7a596e9b281e8afade68896e8b1aae890a8e8afad0a0a> def

/msg [ barcode {} forall ] def
/msglen msg length def

    % Convert from input into message bitstream
    /N 0 def  /T1 1 def  /T2 2 def  /C1 3 def  /C2 4 def  /CD 5 def  /CQ 6 def  /B 7 def

    /T1vals <<
        48 1  57 {dup 48 sub} for
        65 1  90 {dup 55 sub} for
        97 1 122 {dup 61 sub} for
    >> def

    /T2vals <<
          0 1  27 {dup       } for
         32 1  47 {dup  4 sub} for
         58 1  64 {dup 14 sub} for
         91 1  96 {dup 40 sub} for
        123 1 127 {dup 66 sub} for
    >> def

    /isNexcl {
        0 get dup 48 ge exch 57 le and
    } bind def

    /T1excl <<
        65 1  90 {dup 55 sub} for
        97 1 122 {dup 61 sub} for
    >> def

    /isT1excl {
        0 get T1excl exch known
    } bind def

    /isT2excl {
        0 get T2vals exch known
    } bind def

    /isC1excl {
        {  % common exit
            dup dup 0 get dup 16#B0 ge exch 16#D7 le and exch 1 get dup 16#A1 ge exch 16#FE le and and {pop true exit} if  % {B0-D7}{A1-FE}
            dup dup 0 get dup 16#A1 ge exch 16#A3 le and exch 1 get dup 16#A1 ge exch 16#FE le and and {pop true exit} if  % {A1-A3}{A1-FE}
            dup dup 0 get 16#A8 eq exch                       1 get dup 16#A1 ge exch 16#C0 le and and {pop true exit} if  % {A8}{A1-C0}
            pop false exit
        } loop
    } bind def

    /isC2excl {
        dup 0 get dup 16#D8 ge exch 16#F7 le and exch 1 get dup 16#A1 ge exch 16#FE le and and  % {D8-F7}{A1-FE}
    } bind def

    /isCDexcl {
        {  % common exit
            dup isC1excl {pop false exit} if
            dup isC2excl {pop false exit} if
            dup dup 0 get dup 16#81 ge exch 16#FE le and exch 1 get dup 16#40 ge exch 16#7E le and and {pop true exit} if  % {81-FE}{40-7E}
            dup dup 0 get dup 16#81 ge exch 16#FE le and exch 1 get dup 16#80 ge exch 16#FE le and and {pop true exit} if  % {81-FE}{80-FE}
            pop false exit
        } loop
    } bind def

    /isCQexcl {
        dup 0 get dup 16#81 ge exch 16#FE le and exch  % {81-FE}
        dup 1 get dup 16#30 ge exch 16#39 le and exch  %        {30-39}
        dup 2 get dup 16#81 ge exch 16#FE le and exch  %               {81-FE}
        3 get dup 16#30 ge exch 16#39 le and           %                      {30-39}
        and and and
    } bind def

    /Bexcl <<
         [ 28 29 30 128 255 ] {dup} forall
    >> def

    /isBexcl {
        0 get Bexcl exch known
    } bind def

    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs
        dup length 2 index length exch sub exch putinterval
    } bind def

    /encN {
        /in exch def
        /out in length 2 add 3 idiv 10 mul 14 add string def
        out 0 (0001) putinterval
        /k 0 def /m 4 def {
            k in length eq {exit} if
            k in length 3 sub lt {
                in k 3 getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin
                /k k 3 add def
            } {
                /rem in length k sub def
                in k rem getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin
                20 string dup 0 4 -1 roll putinterval
                dup 10 [ (1111111101) (1111111110) (1111111111) ] rem 1 sub get putinterval
                /k k rem add def
            } ifelse
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out
    } bind def

    /encT {
        /in exch def
        /out in length 12 mul 10 add string def
        out 0 (0010) putinterval
        /k 0 def /m 4 def /submode 1 def {
            k in length eq {exit} if
            submode 1 eq {T1vals} {T2vals} ifelse in k get known not {
                out m (111110) putinterval
                /m m 6 add def
                /submode 3 submode sub def
            } if
            submode 1 eq {T1vals} {T2vals} ifelse in k get get 6 tobin
            /k k 1 add def
            dup out exch m exch putinterval
            length m add /m exch def
        } loop
        out m (111111) putinterval
        out 0 m 6 add getinterval
    } bind def

    /encB {
        /in exch sef
        /out 17 in length 8 mul add string def
        out 0 (0011) putinterval
        out 4 in length 13 tobin putinterval
        0 1 in length 1 sub {
            /k exch def
            in k get cvi 8 tobin
            out 17 k 8 mul add 3 -1 roll putinterval
        } for
        out
    } bind def

    /encC1 {
        /in exch def
        /out 16 in length 6 mul add string def
        out 0 (0100) putinterval
        0 1 in length 2 idiv 1 sub {
            /k exch def
            /b1 in k 2 mul get def
            /b2 in k 2 mul 1 add get def
            b1 16#B0 ge {
                b1 16#B0 sub 16#5E mul b2 16#A1 sub add
            } if
            b1 16#A3 le {
                b1 16#A1 sub 16#5E mul b2 16#A1 sub add 16#0EB0 add
            } if
            b1 16#A8 eq {
                b2 16#A1 sub 16#0FCA add
            } if
            12 tobin out exch 4 k 12 mul add exch putinterval
        } for
        out out length 12 sub (111111111111) 12 string copy putinterval
        out
    } bind def

    /encC2 {
        /in exch def
        /out 16 in length 6 mul add string def
        out 0 (0101) putinterval
        0 1 in length 2 idiv 1 sub {
            /k exch def
            /b1 in k 2 mul get def
            /b2 in k 2 mul 1 add get def
            b1 16#D8 sub 16#5E mul b2 16#A1 sub add
            12 tobin out exch 4 k 12 mul add exch putinterval
        } for
        out out length 12 sub (111111111111) 12 string copy putinterval
        out
    } bind def

    /encCD {
        /in exch def
        /out 19 in length 2 idiv 15 mul add string def
        out 0 (0110) putinterval
        0 1 in length 2 idiv 1 sub {
            /k exch def
            /b1 in k 2 mul get def
            /b2 in k 2 mul 1 add get def
            b1 16#81 sub 16#BE mul b2 add 
            b2 16#80 ge {16#41} {16#40} ifelse sub
            15 tobin out exch 4 k 15 mul add exch putinterval
        } for
        out out length 15 sub (111111111111111) 15 string copy putinterval
        out
    } bind def

    /encCQ {
        /in exch def
        /out 25 string def
        out 0 (0111) putinterval
        in 0 get 16#81 sub 16#3138 mul
        in 1 get 16#30 sub 16#04EC mul add
        in 2 get 16#81 sub 16#000A mul add
        in 3 get 16#30 sub add
        21 tobin out exch 4 exch putinterval
        out
    } bind def

    /numNs  [ msglen {0} repeat 0 ] def
    /numT1s [ msglen {0} repeat 0 ] def
    /numT2s [ msglen {0} repeat 0 ] def
    /numC1s [ msglen {0} repeat -1 ] def  % 2 byte
    /numC2s [ msglen {0} repeat -1 ] def  % 2 byte
    /numCDs [ msglen {0} repeat -1 ] def  % 2 byte
    /numCQs [ msglen {0} repeat -1 ] def  % 4 byte  % TODO fix
    /numBs  [ msglen {0} repeat 0 ] def
    /nextNs  [ msglen {0} repeat 9999 ] def
    /nextT1s [ msglen {0} repeat 9999 ] def
    /nextT2s [ msglen {0} repeat 9999 ] def
    /nextC1s [ msglen {0} repeat 9999 ] def
    /nextC1s [ msglen {0} repeat 9999 ] def
    /nextC2s [ msglen {0} repeat 9999 ] def
    /nextCDs [ msglen {0} repeat 9999 ] def
    /nextCQs [ msglen {0} repeat 9999 ] def
    /nextBs  [ msglen {0} repeat 9999 ] def

    msglen 1 sub -1 0 {
        /i exch def
        msg i 1 getinterval isNexcl {
            nextNs i 0 put
            numNs i numNs i 1 add get 1 add put
        } {
            nextNs i nextNs i 1 add get 1 add put
        } ifelse
        msg i 1 getinterval isT1excl {
            nextT1s i 0 put
            numT1s i numT1s i 1 add get 1 add put
        } {
            nextT1s i nextT1s i 1 add get 1 add put
        } ifelse
        msg i 1 getinterval isT2excl {
            nextT2s i 0 put
            numT2s i numT2s i 1 add get 1 add put
        } {
            nextT2s i nextT2s i 1 add get 1 add put
        } ifelse
        msg i 1 getinterval isBexcl {
            nextBs i 0 put
            numBs i numBs i 1 add get 1 add put
        } {
            nextBs i nextBs i 1 add get 1 add put
        } ifelse
    } for
    msglen 2 sub -1 0 {
        /i exch def
        msg i 2 getinterval isC1excl {
            nextC1s i 0 put
            numC1s i numC1s i 1 add get 1 add put
        } {
            nextC1s i nextC1s i 1 add get 1 add put
        } ifelse
        msg i 2 getinterval isC2excl {
            nextC2s i 0 put
            numC2s i numC2s i 1 add get 1 add put
        } {
            nextC2s i nextC2s i 1 add get 1 add put
        } ifelse
        msg i 2 getinterval isCDexcl {
            nextCDs i 0 put
            numCDs i numCDs i 1 add get 1 add put
        } {
            nextCDs i nextCDs i 1 add get 1 add put
        } ifelse
    } for
    msglen 4 sub -1 0 {
        /i exch def
        msg i 4 getinterval isCQexcl {
            nextCQs i 0 put
            numCQs i numCQs i 1 add get 1 add put
        } {
            nextCQs i nextCQs i 1 add get 1 add put
        } ifelse
    } for
    /numC1s [ numC1s {1 add 2 idiv} forall ] def
    /numC2s [ numC2s {1 add 2 idiv} forall ] def
    /numCDs [ numCDs {1 add 2 idiv} forall ] def
    /numCQs [ numCQs {1 add 4 idiv} forall ] def

<c8aba3bba8be> encC1 ==
<F3A3> encC2 ==
<9D519eaf> encCD ==
<8139EF30> encCQ ==
(1212312893712313) encN ==
(Test!) encT == asdf

