%!PS

% Barcode Writer in Pure PostScript
% http://bwipp.terryburton.co.uk
%
% Copyright (c) 2004-2014 Terry Burton
%
% $Id$
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% --BEGIN ENCODER codeone--
% --REQUIRES preamble raiseerror renmatrix--
% --DESC: Code One
% --EXAM: Code One
% --EXOP: version=B
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codeone {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /version (unset) def
    /encoding (ascii) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    /stype version 0 1 getinterval (S) eq def
    stype {/encoding (stype) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (stype) eq {
        /vals [
            [   (0)   (1)  (10)   (11)  (100)
              (101) (110) (111) (1000) (1001)
            ]
            [      (0)   (1010)   (10100)   (11110)  (101000)
              (110010) (111100) (1000110) (1010000) (1011010)
            ]
            [ (0) (1100100)   (11001000)  (100101100)
                (110010000)  (111110100) (1001011000)
               (1010111100) (1100100000) (1110000100)
            ]
            [ (0) (1111101000)   (11111010000)   (101110111000)
                (111110100000) (1001110001000)  (1011101110000)
               (1101101011000) (1111101000000) (10001100101000)
            ]
            [ (0) (10011100010000)   (100111000100000)   (111010100110000)
                (1001110001000000)  (1100001101010000)  (1110101001100000)
               (10001000101110000) (10011100010000000) (10101111110010000)
            ]
            [ (0) (11000011010100000)   (110000110101000000)  (1001001001111100000)
                (1100001101010000000)  (1111010000100100000) (10010010011111000000)
               (10101010111001100000) (11000011010100000000) (11011011101110100000)
            ]
            [                        (0)     (11110100001001000000)
                 (111101000010010000000)   (1011011100011011000000)
                (1111010000100100000000)  (10011000100101101000000)
               (10110111000110110000000)  (11010101100111111000000)
               (11110100001001000000000) (100010010101010001000000)
            ]
            [                           (0)    (100110001001011010000000)
                (1001100010010110100000000)   (1110010011100001110000000)
               (10011000100101101000000000)  (10111110101111000010000000)
               (11100100111000011100000000) (100001011000001110110000000)
              (100110001001011010000000000) (101010111010100101010000000)
            ]
            [                              (0)    (101111101011110000100000000)
                (1011111010111100001000000000)  (10001111000011010001100000000)
               (10111110101111000010000000000)  (11101110011010110010100000000)
              (100011110000110100011000000000) (101001101110010010011100000000)
              (101111101011110000100000000000) (110101101001001110100100000000)
            ]
            [                                 (0)     (111011100110101100101000000000)
                (1110111001101011001010000000000)   (10110010110100000101111000000000)
               (11101110011010110010100000000000)  (100101010000001011111001000000000)
              (101100101101000001011110000000000)  (110100001001110111000011000000000)
              (111011100110101100101000000000000) (1000011000011100010001101000000000)
            ]
            [ (0) (1001010100000010111110010000000000)
                 (10010101000000101111100100000000000)
                 (11011111100001000111010110000000000)
                (100101010000001011111001000000000000)
                (101110100100001110110111010000000000)
                (110111111000010001110101100000000000)
               (1000001001100010100110011110000000000)
               (1001010100000010111110010000000000000)
               (1010011110100011010110000010000000000)
            ]
            [ (0) (1011101001000011101101110100000000000)
                 (10111010010000111011011101000000000000)
                (100010111011001011001001011100000000000)
                (101110100100001110110111010000000000000)
                (111010001101010010100101000100000000000)
               (1000101110110010110010010111000000000000)
               (1010001011111011010000000101100000000000)
               (1011101001000011101101110100000000000000)
               (1101000110001100001011100010100000000000)
            ]
            [ (0) (1110100011010100101001010001000000000000)
                 (11101000110101001010010100010000000000000)
                (101011101001111101111011110011000000000000)
                (111010001101010010100101000100000000000000)
               (1001000110000100111001110010101000000000000)
               (1010111010011111011110111100110000000000000)
               (1100101110111010000100000110111000000000000)
               (1110100011010100101001010001000000000000000)
              (10000010111101111001110011011001000000000000)
            ]
            [ (0) (10010001100001001110011100101010000000000000)
                 (100100011000010011100111001010100000000000000)
                 (110110100100011101011010101111110000000000000)
                (1001000110000100111001110010101000000000000000)
                (1011010111100110001000001111010010000000000000)
                (1101101001000111010110101011111100000000000000)
                (1111111010101000100101001000100110000000000000)
               (10010001100001001110011100101010000000000000000)
               (10100011101101011000010000001111010000000000000)
            ]
            [ (0) (10110101111001100010000011110100100000000000000)
                 (101101011110011000100000111101001000000000000000)
                (1000100001101100100110001011011101100000000000000)
                (1011010111100110001000001111010010000000000000000)
                (1110001101011111101010010011000110100000000000000)
               (10001000011011001001100010110111011000000000000000)
               (10011111001010010101110011010101111100000000000000)
               (10110101111001100010000011110100100000000000000000)
               (11001100101000101110010100010011000100000000000000)
            ]
            [ (0) (11100011010111111010100100110001101000000000000000)
                 (111000110101111110101001001100011010000000000000000)
                (1010101010000111101111101110010100111000000000000000)
                (1110001101011111101010010011000110100000000000000000)
               (10001110000110111100100110111111000001000000000000000)
               (10101010100001111011111011100101001110000000000000000)
               (11000110111100111011010000001011011011000000000000000)
               (11100011010111111010100100110001101000000000000000000)
               (11111111110010111001111001010111110101000000000000000)
            ]
            [ (0) (100011100001101111001001101111110000010000000000000000)
                 (1000111000011011110010011011111100000100000000000000000)
                 (1101010100101001101011101001111010000110000000000000000)
                (10001110000110111100100110111111000001000000000000000000)
                (10110001101000101011110000101110110001010000000000000000)
                (11010101001010011010111010011110100001100000000000000000)
                (11111000101100001010000100001110010001110000000000000000)
               (100011100001101111001001101111110000010000000000000000000)
               (100111111101111101000010111101101110010010000000000000000)
            ]
            [ (0) (101100011010001010111100001011101100010100000000000000000)
                 (1011000110100010101111000010111011000101000000000000000000)
                (10000101001110100000110100100011000100111100000000000000000)
                (10110001101000101011110000101110110001010000000000000000000)
                (11011110000010110110101100111010011101100100000000000000000)
               (100001010011101000001101001000110001001111000000000000000000)
               (100110110110111001100100101010001110110001100000000000000000)
               (101100011010001010111100001011101100010100000000000000000000)
               (110001111101011100010011101101001001110110100000000000000000)
            ]
        ] def

        /normalize {
            /base exch def
            /num exch def
            num length 1 sub -1 1 {
                /i exch def
                num i 1 sub 2 copy get num i get base idiv add put
                num i num i get base mod put
            } for
            { %loop - extend input as necessary
                num 0 get base lt {exit} if
                /num [0 num {} forall] def
                num 0 num 0 get num 1 get base idiv add put
                num 1 num 1 get base mod put
            } loop
            % Trim leading zeros
            /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def
            num length 0 eq {/num [0] def} if
            num
        } bind def

        /bigadd {
            2 copy length exch length
            2 copy sub abs /offset exch def
            lt {exch} if
            /a exch def /b exch def
            0 1 b length 1 sub {
                dup a exch offset add 2 copy get b 5 -1 roll get add put
            } for
            a
        } bind def

        % Convert value plus one to binary
        /v [ 1 ] def
        0 1 barlen 1 sub {
            /i exch def
            vals i get barcode barlen i sub 1 sub get 48 sub get
            [ exch {48 sub} forall ] v bigadd /v exch def
        } for
        /v v 2 normalize def

        % Split into 5-bit codewords
        /v [ 5 v length 5 mod sub 5 mod {0} repeat v aload pop ] def
        /cws v length 5 idiv array def
        0 1 cws length 1 sub {
            /i exch def
            v i 5 mul 5 getinterval
            0 exch {add 2 mul} forall 2 idiv
            cws exch i exch put
        } for

    } if

    % Basic metrics for the each symbol
    %     ver    row col dcol dcws rscw rsbl  ro ri rl
    /metrics [
        [ (A)     16  18   16   10   10    1   4 99  6 ]
        [ (B)     22  22   20   19   16    1   4 99  8 ]
        [ (C)     28  32   28   44   26    1   4 22 11 ]
        [ (D)     40  42   36   91   44    1   4 16 16 ]
        [ (E)     52  54   48  182   70    1   4 22 22 ]
        [ (F)     70  76   68  370  140    2   4 22 31 ]
        [ (G)    104  98   88  732  280    4   6 21 47 ]
        [ (H)    148 134  120 1480  560    8   6 20 69 ]
        [ (S-10)   8  11   10    4    4    1  99 99 99 ]
        [ (S-20)   8  21   20    8    8    1  99 99 99 ]
        [ (S-30)   8  31   30   12   12    1  99 99 99 ]
        [ (T-16)  16  17   16   10   10    1  99 99 99 ]
        [ (T-32)  16  33   32   24   16    1  99 99 99 ]
        [ (T-48)  16  49   48   38   22    1  99 99 99 ]
    ] def

    % Select metrics of an appropriate symbol
    /i 0 def
    { % loop
        /m metrics i get def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords 
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } {
        /cws [ dcws cws length sub {0} repeat cws aload pop ] def
    } ifelse

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def 
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
    } for

    % Log and anti-log tables and function to calculate product in the field
    /gf stype {32} {256} ifelse def
    /gf-1 gf 1 sub def
    /pm stype {37} {301} ifelse def
    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def
    /rslog gf array def
    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    % Extend codewords with the interleaved error correction codes
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Module matrix for layout of the codewords
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    % Create bitmap and add finder patterns
    /mmv {cols mul add} bind def
    /pixs [ rows cols mul {-1} repeat ] def

    % Centre pattern
    /artifact [
        {cols {0} repeat} bind 
        {cols {1} repeat} bind 
        {0   cols 2 sub {1} repeat   0} bind 
        {0 1 cols 4 sub {0} repeat 1 0} bind 
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind 
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind 
        {1   cols 2 sub {0} repeat   1} bind 
        {1 0 cols 4 sub {1} repeat 0 1} bind 
    ] def
    /cpat <<
        /A (121343)
        /B (12134343)
        /C (12121343)
        /D (1213434343)
        /E (1212134343)
        /F (1212121343)
        /G (121213434343)
        /H (121212134343)
        /S (56661278)
        /T (5666666666127878)
    >> vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv 
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    % Risers
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv 
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    % Black dots
    <<
        /A [ [12 5] ]
        /B [ [16 7] ]
        /C [ [26 12] ]
        /D []
        /E [ [26 23] ]
        /F [ [26 32] [70 32] [26 34] [70 34] ]
        /G [ [27 48] [69 48] ]
        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
        /S-10 []
        /S-20 [ [10 4] ]
        /S-30 [ [15 4] [15 6] ]
        /T-16 [ [8 10] ]
        /T-32 [ [16 10] [16 12] ]
        /T-48 [ [24 10] [24 12] [24 14] ]
    >> vers get {pixs exch aload pop mmv 1 put} forall

    % Place the modules onto a pixel map between alignment patterns
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 2 mul
    /width cols 72 div 2 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codeone--
